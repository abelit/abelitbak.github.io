import{_ as e}from"./redis-ha-master-slave-archtecture-001-D8DYfrEH.js";import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as l,f as s}from"./app-DR5J2daJ.js";const t="/assets/redis-ha-master-slave-archtecture-003-Be0c8geV.jpg",n="/assets/redis-ha-master-slave-replication-001-CDIXlWj2.png",r={},d=s('<h2 id="redis主从复制" tabindex="-1"><a class="header-anchor" href="#redis主从复制"><span>Redis主从复制</span></a></h2><h3 id="拓扑架构" tabindex="-1"><a class="header-anchor" href="#拓扑架构"><span>拓扑架构</span></a></h3><figure><img src="'+e+'" alt="主从架构图" tabindex="0" loading="lazy"><figcaption>主从架构图</figcaption></figure><h3 id="redis主从原理" tabindex="-1"><a class="header-anchor" href="#redis主从原理"><span>Redis主从原理</span></a></h3><p>Slave 启动成功连接到 master 后会发送一个sync同步命令</p><p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><p>Redis的主从结构可以采用一主多从或者级联结构，Redis主从复制可以根据是否是全量分为全量同步和增量同步。</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="全量同步" tabindex="-1"><a class="header-anchor" href="#全量同步"><span>全量同步</span></a></h4><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：</p><ol><li>从服务器连接主服务器，发送SYNC命令；</li><li>主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；</li><li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li><li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li><li>slave完成上面的数据初始化后就可以开始接受用户的读请求了。</li></ol><figure><img src="'+n+'" alt="全量复制基本流程" tabindex="0" loading="lazy"><figcaption>全量复制基本流程</figcaption></figure><h4 id="增量同步" tabindex="-1"><a class="header-anchor" href="#增量同步"><span>增量同步</span></a></h4><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p><h4 id="redis主从同步策略" tabindex="-1"><a class="header-anchor" href="#redis主从同步策略"><span>Redis主从同步策略</span></a></h4><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p><p>注意：</p><ol><li>主机可以写，从机不可以；</li><li>主机如果宕机，重新连接以后，依旧可以成功连接；</li><li>如果有Slave断开，一旦重新连接就会触发全量复制；</li><li>如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。</li></ol><h3 id="redis主从复制的主要作用" tabindex="-1"><a class="header-anchor" href="#redis主从复制的主要作用"><span>Redis主从复制的主要作用</span></a></h3><ol><li><p>数据冗余：主从复制实现了数据的热备份，是持久化的一种数据冗余方式；</p></li><li><p>故障恢复：主节点一旦出现问题，可以由从节点提供服务，避免出现程序不可用的情况，实现快速故障恢复；</p></li><li><p>负载均衡：在主从复制的基础之上，配合读写分离，主节点提供写服务，由从节点提供读服务，分担服务器负载，尤其是在读多写少场景下，可以大大提高Redis并发量；</p></li><li><p>读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；</p></li><li><p>高可用（集群）基石：主从复制是集群和哨兵模式的基础。</p></li></ol><h2 id="redis哨兵" tabindex="-1"><a class="header-anchor" href="#redis哨兵"><span>Redis哨兵</span></a></h2><h3 id="什么是redis哨兵" tabindex="-1"><a class="header-anchor" href="#什么是redis哨兵"><span>什么是redis哨兵？</span></a></h3><p>Redis Sentinel是Redis 的高可用性解决方案，由一个或多个Sentinel（哨兵）实例组成。它可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，它的主要功能如下：</p><p>监控(Monitoring)：Sentinel会不断地检查你的主服务器和从服务器是否运作正常。</p><p>通知(Notification)：当被监控的某个 Redis 服务器出现问题时， Sentinel可以通过API向管理员或者其他应用程序发送通知。</p><p>故障迁移：当主服务器不能正常工作时，Sentinel会自动进行故障迁移，也就是主从切换。</p><p>统一的配置：管理连接者询问sentinel取得主从的地址。</p><h3 id="哨兵原理是什么" tabindex="-1"><a class="header-anchor" href="#哨兵原理是什么"><span>哨兵原理是什么？</span></a></h3><p>Sentinel 使用的算法核心是 Raft算法，主要用途就是用于分布式系统，系统容错，以及Leader选举，每个Sentinel都需要定期的执行以下任务：</p><p>每个 Sentinel会自动发现其他 Sentinel 和从服务器，它以每秒钟一次的频率向它所知的主服务器、从服务器以及其他Sentinel实例发送一个 PING 命令。</p><p>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds选项所指定的值， 那么这个实例会被Sentinel标记为主观下线。 有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN 。</p><p>如果一个主服务器被标记为主观下线， 那么正在监视这个主服务器的所有Sentinel要以每秒一次的频率确认主服务器的确进入了主观下线状态。</p><p>如果一个主服务器被标记为主观下线， 并且有足够数量的Sentinel（至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。</p><p>在一般情况下， 每个Sentinel会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。当一个主服务器Sentinel标记为客观下线时，Sentinel向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10秒一次改为每秒一次。</p><p>当没有足够数量的Sentinel同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向Sentinel的 PING命令返回有效回复时， 主服务器的主管下线状态就会被移除。</p><h3 id="哨兵模式的优缺点" tabindex="-1"><a class="header-anchor" href="#哨兵模式的优缺点"><span>哨兵模式的优缺点</span></a></h3><ol><li><p>优点 哨兵集群，基于主从复制模式，所有的主从配置优点，它全有主从可以切换，故障可以转移，系统的可用性就会更好哨兵模式就是主从模式的升级，手动到自动，更加健壮！</p></li><li><p>缺点 Redis不好在线扩容，集群容量一旦到达上限，在线扩容就十分麻烦哨兵模式的配置繁琐</p></li></ol><h2 id="redis集群" tabindex="-1"><a class="header-anchor" href="#redis集群"><span>Redis集群</span></a></h2><h3 id="什么是集群" tabindex="-1"><a class="header-anchor" href="#什么是集群"><span>什么是集群</span></a></h3><p>Redis 集群（包括很多小集群）实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N，即一个小集群存储1/N的数据，每个小集群里面维护好自己的1/N的数据。 Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。 该模式的redis集群特点是：分治、分片。</p><h3 id="为什么使用" tabindex="-1"><a class="header-anchor" href="#为什么使用"><span>为什么使用</span></a></h3><ol><li><p>容量不够，redis如何进行扩容？</p></li><li><p>并发写操作， redis如何分摊？</p></li><li><p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p></li><li><p>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p></li></ol><h3 id="集群连接" tabindex="-1"><a class="header-anchor" href="#集群连接"><span>集群连接</span></a></h3><ol><li>普通方式登录：可能直接进入读主机，存储数据时，会出现MOVED重定向操作，所以，应该以集群方式登录。</li><li>集群登录：redis-cli -c -p 6379 采用集群策略连接，设置数据会自动切换到相应的写主机。</li></ol><h3 id="redis-cluster-如何分配这六个节点" tabindex="-1"><a class="header-anchor" href="#redis-cluster-如何分配这六个节点"><span>redis cluster 如何分配这六个节点?</span></a></h3><ol><li><p>一个集群至少要有三个主节点。</p></li><li><p>选项 –cluster-replicas 1 ：表示我们希望为集群中的每个主节点创建一个从节点。</p></li><li><p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p></li></ol>',46),p=[d];function o(h,c){return a(),l("div",null,p)}const f=i(r,[["render",o],["__file","hasolution.html.vue"]]),R=JSON.parse('{"path":"/guide/database/redis/ha/hasolution.html","title":"Redis高可用方案","lang":"zh-CN","frontmatter":{"title":"Redis高可用方案","description":"Redis主从复制 拓扑架构 主从架构图主从架构图 Redis主从原理 Slave 启动成功连接到 master 后会发送一个sync同步命令 Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。 Redis的主从结构可以采用一主多从...","head":[["meta",{"property":"og:url","content":"https://github.com/abelit/abelit-datapeacock.git/guide/database/redis/ha/hasolution.html"}],["meta",{"property":"og:site_name","content":"数之雀"}],["meta",{"property":"og:title","content":"Redis高可用方案"}],["meta",{"property":"og:description","content":"Redis主从复制 拓扑架构 主从架构图主从架构图 Redis主从原理 Slave 启动成功连接到 master 后会发送一个sync同步命令 Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。 Redis的主从结构可以采用一主多从..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-11T14:06:18.000Z"}],["meta",{"property":"article:author","content":"Abelit"}],["meta",{"property":"article:modified_time","content":"2024-05-11T14:06:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis高可用方案\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-11T14:06:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Abelit\\",\\"url\\":\\"https://github.com/abelit\\"}]}"]]},"headers":[{"level":2,"title":"Redis主从复制","slug":"redis主从复制","link":"#redis主从复制","children":[{"level":3,"title":"拓扑架构","slug":"拓扑架构","link":"#拓扑架构","children":[]},{"level":3,"title":"Redis主从原理","slug":"redis主从原理","link":"#redis主从原理","children":[]},{"level":3,"title":"Redis主从复制的主要作用","slug":"redis主从复制的主要作用","link":"#redis主从复制的主要作用","children":[]}]},{"level":2,"title":"Redis哨兵","slug":"redis哨兵","link":"#redis哨兵","children":[{"level":3,"title":"什么是redis哨兵？","slug":"什么是redis哨兵","link":"#什么是redis哨兵","children":[]},{"level":3,"title":"哨兵原理是什么？","slug":"哨兵原理是什么","link":"#哨兵原理是什么","children":[]},{"level":3,"title":"哨兵模式的优缺点","slug":"哨兵模式的优缺点","link":"#哨兵模式的优缺点","children":[]}]},{"level":2,"title":"Redis集群","slug":"redis集群","link":"#redis集群","children":[{"level":3,"title":"什么是集群","slug":"什么是集群","link":"#什么是集群","children":[]},{"level":3,"title":"为什么使用","slug":"为什么使用","link":"#为什么使用","children":[]},{"level":3,"title":"集群连接","slug":"集群连接","link":"#集群连接","children":[]},{"level":3,"title":"redis cluster 如何分配这六个节点?","slug":"redis-cluster-如何分配这六个节点","link":"#redis-cluster-如何分配这六个节点","children":[]}]}],"git":{"createdTime":1715436378000,"updatedTime":1715436378000,"contributors":[{"name":"ableit","email":"ychenid@live.com","commits":1}]},"readingTime":{"minutes":7.43,"words":2230},"filePathRelative":"guide/database/redis/ha/hasolution.md","localizedDate":"2024年5月11日","autoDesc":true,"excerpt":"<h2>Redis主从复制</h2>\\n<h3>拓扑架构</h3>\\n<figure><figcaption>主从架构图</figcaption></figure>\\n<h3>Redis主从原理</h3>\\n<p>Slave 启动成功连接到 master 后会发送一个sync同步命令</p>\\n<p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p>\\n<p>Redis的主从结构可以采用一主多从或者级联结构，Redis主从复制可以根据是否是全量分为全量同步和增量同步。</p>\\n"}');export{f as comp,R as data};
