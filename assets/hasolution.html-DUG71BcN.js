import{_ as e}from"./mongodb-replication-pnxoiu53rz-BbvfOOSv.js";import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as a,f as t}from"./app-DR5J2daJ.js";const n="/assets/kseryedf3pajb7i31-mongodb-replicaset-L-pJPqXK.avif",l="/assets/kses274yc8v1e1ysq-mongodb-replicaset-primary-failure-BRVxvoY1.avif",r="/assets/kses5vu00lg0ikrr4-mongodb-replicaset-primary-back-online-C6Q9F9u0.avif",p="/assets/replica-set-trigger-election.bakedsvg-CypeVbBX.svg",s={},c=t('<h2 id="mongodb高可用方案" tabindex="-1"><a class="header-anchor" href="#mongodb高可用方案"><span>MongoDB高可用方案</span></a></h2><p>MongoDB 是一款非常流行的分布式文档数据库，它提供了多种高可用架构，主要有以下四种：</p><ul><li><strong>主从模式（Master-Slave）</strong>：这是一种最简单的冗余策略，主节点负责读写操作，从节点只负责同步主节点的数据，并提供读服务。这种模式可以实现备份和读写分离，但是主节点宕机后不能自动恢复，需要人工干预。MongoDB 3.6 起已不推荐使用这种模式。</li><li><strong>副本集模式（Replica Set）</strong>：这是一种更高级的冗余策略，副本集由一个主节点和多个从节点组成，主节点负责读写操作，从节点负责同步主节点的数据，并提供读服务。副本集支持自动故障转移和选主机制，当主节点宕机后，从节点会通过投票选举出一个新的主节点，保证服务的可用性。副本集还支持仲裁者（Arbiter）节点，它不存储数据，只参与选主投票。</li><li><strong>分片模式（Sharding）</strong>：这是一种用于解决海量数据存储和高并发访问的策略，分片模式将数据按照一定的规则分散到不同的分片（Shard）上，每个分片可以是一个单独的 mongod 实例，也可以是一个副本集。分片模式还涉及到查询路由（Query Router）和配置服务器（Config Server）两种角色，它们负责维护集群的元数据和路由规则。</li><li><strong>副本集 + 分片</strong>：这种方案将副本集和分片结合起来，实现了高可用性和高扩展性的双重保障。</li></ul><p>具体选择哪种方案，需要根据实际应用场景来决定。如果数据量比较小，不需要考虑高可扩展性，那么副本集是一个不错的选择。如果数据量比较大，需要考虑高可扩展性，那么分片是一个更好的选择。如果需要同时考虑高可用性和高扩展性，那么可以采用副本集 + 分片的方案。</p><p>以下是几点关于 MongoDB 高可用方案的注意事项：</p><ul><li>副本集的节点数至少为 3，这样才能保证在主节点发生故障时，副本节点可以正常选举出新的主节点。</li><li>分片集群的节点数至少为 3，这样才能保证在分片节点发生故障时，路由节点可以正常将读写请求路由到其他分片节点。</li><li>MongoDB 的高可用方案需要配合其他的措施，比如备份、监控等，才能确保数据库的安全性和可用性。</li></ul><h2 id="副本集模式-replica-set" tabindex="-1"><a class="header-anchor" href="#副本集模式-replica-set"><span>副本集模式（Replica Set）</span></a></h2><p>MongoDB 副本集是一组包含数据的精确副本的一个或多个服务器。虽然从技术上讲可以有一个或两个节点，但建议的最少数量是三个。主节点负责提供应用程序的读取和写入操作，而两个辅助节点则包含数据的副本。</p><figure><img src="'+n+'" alt="MongoDB 中典型的副本集" tabindex="0" loading="lazy"><figcaption>MongoDB 中典型的副本集</figcaption></figure><p>如果主节点由于某种原因变得不可用，则新的主节点将被选择选举过程。这个新的主节点现在负责读取和写入操作。如果主节点不可用，来自客户端应用程序的流量将被重定向到新的主节点。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一旦故障服务器重新上线，它将与主节点同步并成为集群中新的辅助节点。 <img src="'+r+'" alt="" loading="lazy"></p><h3 id="mongodb-中的复制是如何工作的" tabindex="-1"><a class="header-anchor" href="#mongodb-中的复制是如何工作的"><span>MongoDB 中的复制是如何工作的？</span></a></h3><p>复制的存在主要是为了提供数据冗余和高可用性。我们通过在物理隔离的服务器上保留数据的多个副本或副本来保持数据的持久性。这就是复制：创建冗余数据以简化和保护数据可用性和持久性的过程。</p><p>复制允许您通过跨服务器创建数据的多个副本来提高数据可用性。如果服务器崩溃或者您遇到服务中断或硬件故障，这尤其有用。</p><p>如果您的数据仅驻留在单个数据库中，则任何这些事件都将导致无法访问数据。但借助复制，您的应用程序可以在数据库服务器发生故障时保持在线状态，同时还提供灾难恢复和备份选项。</p><p>对于 MongoDB，复制是通过副本集实现的。写入器操作被发送到主服务器（节点），主服务器将操作应用于辅助服务器，从而复制数据。</p><p>如果主服务器发生故障（由于崩溃或系统故障），其中一台辅助服务器将接管并通过选举成为新的主节点。如果该服务器重新上线，一旦完全恢复，它就会成为辅助节点，为新的主节点提供帮助。</p><figure><img src="'+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="mongodb-如何检测复制滞后" tabindex="-1"><a class="header-anchor" href="#mongodb-如何检测复制滞后"><span>MongoDB 如何检测复制滞后？</span></a></h3><p>复制延迟是指主服务器上更新后数据复制到辅助服务器的延迟。复制滞后的短窗口是正常的，在选择读取最终一致的辅助数据的系统中应该考虑这一点。如果主服务器出现故障，复制延迟还会阻止辅助服务器承担主服务器的角色。</p><p>如果您想检查当前的复制延迟：</p><p>在连接到主服务器的<code>Mongo shell</code>中，调用<code>rs.printSlaveReplicationInfo()</code> 方法。 这将返回<code>syncedTo</code>每个成员的值，该值显示最后一个 <code>oplog</code> 条目写入辅助服务器的时间。</p><p>复制延迟可能是由多种原因造成的，包括：</p><ul><li><p><strong>网络延迟</strong>：检查 ping 和跟踪路由，看看是否存在网络路由问题或数据包丢失。请参阅：ping 诊断文档、副本集故障排除。</p></li><li><p><strong>磁盘吞吐量</strong>：有时辅助服务器无法像主服务器那样快速地将数据刷新到磁盘。这在多租户系统上很常见，特别是当系统通过 IP 网络访问磁盘设备时。系统级工具（例如 vmstat 或 iostat）可以帮助您了解更多信息。 请参阅：生产说明、mongostat。</p></li><li><p><strong>并发性</strong>：主服务器上长时间运行的操作可能会阻止复制。设置写入关注点，以便在复制无法跟上负载时写入操作不会返回。或者，通过数据库分析器检查慢速查询和长时间运行的操作。请参阅：写下关注点。</p></li><li><p><strong>适当的写入问题</strong>：如果主节点需要大量写入（由于批量加载操作或大量数据摄取），则辅助节点可能无法跟上 oplog 上的更改。考虑将写入关注点设置为“majority”，以确保正确复制大型操作。</p></li></ul><h3 id="复制和分片有什么区别" tabindex="-1"><a class="header-anchor" href="#复制和分片有什么区别"><span>复制和分片有什么区别？</span></a></h3><ul><li><p><strong>复制</strong>：主服务器节点将数据复制到辅助服务器节点。这有助于提高数据可用性，并在主服务器发生故障时充当备份。</p></li><li><p><strong>分片</strong>：使用分片键处理跨服务器的水平扩展。这意味着分片不是整体复制数据，而是跨多个副本集复制数据片段（或“分片”）。这些副本集协同工作以利用所有数据。</p></li></ul><p>把它想象成披萨。通过复制，您可以在每台服务器上制作完整的披萨饼副本。通过分片，您可以将披萨片发送到多个不同的副本集。结合在一起，您就可以享用整个披萨饼。</p><p>复制和分片可以一起形成所谓的分片集群，其中每个分片依次进行复制以保持相同的高可用性。</p><h3 id="复制有什么好处" tabindex="-1"><a class="header-anchor" href="#复制有什么好处"><span>复制有什么好处？</span></a></h3><ul><li>由于存在数据的多个实时副本，它提高了数据可用性和可靠性。</li><li>在发生硬件故障或服务器崩溃等事件时，复制也很有用。复制可以确保您的数据在多个服务器上得到安全保护，而不是遭受停机（或者更糟糕的是完全丢失数据）。</li><li>如果您拥有分布式分析团队，则可以有效地协作开展商业智能项目。</li></ul><h3 id="复制会影响延迟吗" tabindex="-1"><a class="header-anchor" href="#复制会影响延迟吗"><span>复制会影响延迟吗？</span></a></h3><p>复制不会显着影响主服务器的读取或写入延迟。在从副本集辅助节点读取数据有意义的情况下，如果您可以向客户显示最终一致的数据，则可以改善应用程序延迟。</p><h3 id="副本集选举" tabindex="-1"><a class="header-anchor" href="#副本集选举"><span>副本集选举</span></a></h3><p>副本集使用选举来确定哪个集成员将成为主要成员。副本集可以触发选举以响应各种事件，例如：</p><p>将新节点添加到副本集，</p><p>initiating a replica set,</p><p>rs.stepDown()使用或等方法执行副本集维护rs.reconfig()，以及</p><p>次要成员失去与主要成员的连接的时间超过配置的时间timeout（默认情况下为 10 秒）。</p><p>在下图中，主节点不可用的时间超过了configured timeout ，并触发自动故障转移 过程。剩余的辅助节点之一要求进行选举以选择新的主节点并自动恢复正常运行。</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在选举成功完成之前，副本集无法处理写操作。如果此类查询配置为在辅助节点上运行，则副本集可以继续提供读取查询服务 。</p><p>假设默认情况下，集群选举新主节点之前的中位时间通常不应超过 12 秒replica configuration settings。这包括将主节点标记为不可用以及调用并完成请求所需的时间选举。您可以通过修改复制配置选项来调整此时间段 settings.electionTimeoutMillis。网络延迟等因素可能会延长副本集选举完成所需的时间，这反过来又会影响集群在没有主节点的情况下运行的时间。这些因素取决于您特定的集群架构。</p><h4 id="影响选举的因素和条件" tabindex="-1"><a class="header-anchor" href="#影响选举的因素和条件"><span>影响选举的因素和条件</span></a></h4><h5 id="复制选举协议" tabindex="-1"><a class="header-anchor" href="#复制选举协议"><span>复制选举协议</span></a></h5><p>复制<code>protocolVersion: 1</code>减少了副本集故障转移时间并加速了多个同时主节点的检测。</p><p>您可以用来<code>catchUpTimeoutMillis</code>在更快的故障转移和保留<code>w:1</code>写入之间确定优先级。</p><h5 id="心跳" tabindex="-1"><a class="header-anchor" href="#心跳"><span>心跳</span></a></h5><p>副本集成员每两秒向彼此发送一次心跳 (ping)。如果检测信号在 10 秒内未返回，其他成员会将拖欠成员标记为不可访问。</p><h5 id="会员优先" tabindex="-1"><a class="header-anchor" href="#会员优先"><span>会员优先</span></a></h5><p>在副本集拥有稳定的主副本后，选举算法将“尽最大努力”尝试让具有最高 priority可用值的辅助副本进行选举。成员优先级影响选举的时间和结果；具有较高优先级的二级节点比具有较低优先级的二级节点相对更早地发起选举，并且也更有可能获胜。但是，即使有更高优先级的辅助实例可用，也可以在短时间内将优先级较低的实例选为主实例。副本集成员继续进行选举，直到可用的最高优先级成员成为主要成员。</p><p>优先级值为 的成员0不能成为主要成员，也不寻求选举。</p><h5 id="镜像读取" tabindex="-1"><a class="header-anchor" href="#镜像读取"><span>镜像读取</span></a></h5><p>从版本 4.4 开始，MongoDB 提供镜像读取，以使用最近访问的数据预热可选辅助成员的缓存。通过镜像读取，主节点可以镜像它接收到的操作子集，并将它们发送到可选辅助节点的子集。预热辅助节点的缓存有助于在选举后更快地恢复性能。</p><h5 id="数据中心丢失" tabindex="-1"><a class="header-anchor" href="#数据中心丢失"><span>数据中心丢失</span></a></h5><p>对于分布式副本集，一个数据中心的丢失可能会影响其他数据中心或多个数据中心中剩余成员选择主节点的能力。</p><p>如果可能，请将副本集成员分布在数据中心之间，以最大限度地提高即使数据中心丢失，剩余副本集成员之一也可以成为新主副本的可能性。</p><h5 id="网络分区" tabindex="-1"><a class="header-anchor" href="#网络分区"><span>网络分区</span></a></h5><p>网络分区可以将主分区分成具有少数节点的分区。当主节点检测到它只能看到副本集中的少数节点时，主节点就会降级为主节点并成为辅助节点。独立地，分区中可以与节点（包括其自身）通信的成员majority进行选举以成为新的主节点。</p><h4 id="投票会员" tabindex="-1"><a class="header-anchor" href="#投票会员"><span>投票会员</span></a></h4><p>副本集成员配置设置<code>members[n].votes </code>和成员<code>state</code>决定成员是否在选举中投票。</p><ul><li><p>members[n].votes 所有在选举中设置为 1 票的副本集成员。要排除成员在选举中投票，请将成员 members[n].votes配置的值更改为0。</p><ul><li>无投票权（即votes）0成员的投票权必须为 priority0。</li><li>大于 0的成员priority不能有 0 votes。</li></ul></li><li><p>只有以下投票成员才有资格投票：</p><ul><li>PRIMARY</li><li>SECONDARY</li><li>STARTUP2（除非该成员是新添加到副本集中的）</li><li>RECOVERING</li><li>ARBITER</li><li>ROLLBACK</li></ul></li></ul><h4 id="无投票权的成员" tabindex="-1"><a class="header-anchor" href="#无投票权的成员"><span>无投票权的成员</span></a></h4><p>尽管无投票权的成员不在选举中投票，但这些成员持有副本集数据的副本，并且可以接受来自客户端应用程序的读取操作。</p><p>因为一个副本集最多可以有50 个成员，但只有7 个投票成员，所以无投票权成员允许副本集有 7 个以上的成员。</p><p>无投票权（即votes）0成员的投票权必须为 priority0。</p>',66),g=[c];function d(h,m){return i(),a("div",null,g)}const M=o(s,[["render",d],["__file","hasolution.html.vue"]]),v=JSON.parse('{"path":"/guide/database/mongo/ha/hasolution.html","title":"MongoDB高可用方案","lang":"zh-CN","frontmatter":{"title":"MongoDB高可用方案","description":"MongoDB高可用方案 MongoDB 是一款非常流行的分布式文档数据库，它提供了多种高可用架构，主要有以下四种： 主从模式（Master-Slave）：这是一种最简单的冗余策略，主节点负责读写操作，从节点只负责同步主节点的数据，并提供读服务。这种模式可以实现备份和读写分离，但是主节点宕机后不能自动恢复，需要人工干预。MongoDB 3.6 起已不推...","head":[["meta",{"property":"og:url","content":"https://github.com/abelit/abelit-datapeacock.git/guide/database/mongo/ha/hasolution.html"}],["meta",{"property":"og:site_name","content":"数之雀"}],["meta",{"property":"og:title","content":"MongoDB高可用方案"}],["meta",{"property":"og:description","content":"MongoDB高可用方案 MongoDB 是一款非常流行的分布式文档数据库，它提供了多种高可用架构，主要有以下四种： 主从模式（Master-Slave）：这是一种最简单的冗余策略，主节点负责读写操作，从节点只负责同步主节点的数据，并提供读服务。这种模式可以实现备份和读写分离，但是主节点宕机后不能自动恢复，需要人工干预。MongoDB 3.6 起已不推..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-11T14:06:18.000Z"}],["meta",{"property":"article:author","content":"Abelit"}],["meta",{"property":"article:modified_time","content":"2024-05-11T14:06:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MongoDB高可用方案\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-11T14:06:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Abelit\\",\\"url\\":\\"https://github.com/abelit\\"}]}"]]},"headers":[{"level":2,"title":"MongoDB高可用方案","slug":"mongodb高可用方案","link":"#mongodb高可用方案","children":[]},{"level":2,"title":"副本集模式（Replica Set）","slug":"副本集模式-replica-set","link":"#副本集模式-replica-set","children":[{"level":3,"title":"MongoDB 中的复制是如何工作的？","slug":"mongodb-中的复制是如何工作的","link":"#mongodb-中的复制是如何工作的","children":[]},{"level":3,"title":"MongoDB 如何检测复制滞后？","slug":"mongodb-如何检测复制滞后","link":"#mongodb-如何检测复制滞后","children":[]},{"level":3,"title":"复制和分片有什么区别？","slug":"复制和分片有什么区别","link":"#复制和分片有什么区别","children":[]},{"level":3,"title":"复制有什么好处？","slug":"复制有什么好处","link":"#复制有什么好处","children":[]},{"level":3,"title":"复制会影响延迟吗？","slug":"复制会影响延迟吗","link":"#复制会影响延迟吗","children":[]},{"level":3,"title":"副本集选举","slug":"副本集选举","link":"#副本集选举","children":[]}]}],"git":{"createdTime":1715436378000,"updatedTime":1715436378000,"contributors":[{"name":"ableit","email":"ychenid@live.com","commits":1}]},"readingTime":{"minutes":11.52,"words":3456},"filePathRelative":"guide/database/mongo/ha/hasolution.md","localizedDate":"2024年5月11日","autoDesc":true,"excerpt":"<h2>MongoDB高可用方案</h2>\\n<p>MongoDB 是一款非常流行的分布式文档数据库，它提供了多种高可用架构，主要有以下四种：</p>\\n<ul>\\n<li><strong>主从模式（Master-Slave）</strong>：这是一种最简单的冗余策略，主节点负责读写操作，从节点只负责同步主节点的数据，并提供读服务。这种模式可以实现备份和读写分离，但是主节点宕机后不能自动恢复，需要人工干预。MongoDB 3.6 起已不推荐使用这种模式。</li>\\n<li><strong>副本集模式（Replica Set）</strong>：这是一种更高级的冗余策略，副本集由一个主节点和多个从节点组成，主节点负责读写操作，从节点负责同步主节点的数据，并提供读服务。副本集支持自动故障转移和选主机制，当主节点宕机后，从节点会通过投票选举出一个新的主节点，保证服务的可用性。副本集还支持仲裁者（Arbiter）节点，它不存储数据，只参与选主投票。</li>\\n<li><strong>分片模式（Sharding）</strong>：这是一种用于解决海量数据存储和高并发访问的策略，分片模式将数据按照一定的规则分散到不同的分片（Shard）上，每个分片可以是一个单独的 mongod 实例，也可以是一个副本集。分片模式还涉及到查询路由（Query Router）和配置服务器（Config Server）两种角色，它们负责维护集群的元数据和路由规则。</li>\\n<li><strong>副本集 + 分片</strong>：这种方案将副本集和分片结合起来，实现了高可用性和高扩展性的双重保障。</li>\\n</ul>"}');export{M as comp,v as data};
